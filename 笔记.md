# v3-ts-study
[Vue3+TS 快速上手 (24kcs.github.io)](https://24kcs.github.io/vue3_study/)

## 一、typescript

### 1、手动编译TS

- ts文件中直接书法js代码，在html中直接引入ts代码，浏览器可以直接使用。
- 如果有ts代码，需要将ts编译为js文件，再将js引入html。

编译指令：

```
tsc hello-ts.ts
```

### 2、自动编译TS

1）、根目录中生成tsonfig.json

```
tsc --init
```

2）、修改配置文件中的输出路径和是否使用严格模式

3）、点击“终端”—>“运行任务”—>“显示所有任务”—>选择“tsc:监视...”

4）、当保存ts时，代码自动转化为js。

### 3、基础类型

#### 类型注解

​	对于我们自编译的 ts 文件，TypeScript 里的**类型注解**是**一种轻量级的为函数或变量添加约束的方式**。 在这个例子里，我们希望 `greeter` 函数接收一个字符串参数。 然后尝试把 `greeter` 的调用改成传入一个数组：

```typescript
function greeter (person: string) {
  return 'Hello, ' + person
}
let user = [0, 1, 2]
console.log(greeter(user))
```

重新编译，你会看到产生了一个错误：

```
error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.
```

​	类似地，尝试删除 `greeter` 调用的所有参数。 TypeScript 会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了**静态的代码分析，它可以分析代码结构和提供的类型注解**。

​	要注意的是尽管有错误，`greeter.js` 文件还是被创建了。 **就算你的代码里有错误，你仍然可以使用 TypeScript。但在这种情况下，TypeScript 会警告你代码可能不会按预期执行。**

#### Ts 类型机制

Ts拥有和Js一样的类型机制

- 基础类型：布尔、数字、字符串、null、undefined
- 引用类型：数组、object

**Ts新增类型**：

- 元组 tuple：元组类型允许表示一个已知元素数量和类型的数组（let t1: [string, number]），其中t1内部变量赋值顺序不可改变。
- 枚举 enum：为一组数值赋予友好的名字。
- any：为那些在编程阶段还不清楚类型的变量指定一个类型。
- void：表示没有任何类型，通常用于限定函数的返回值。

```typescript
// 元组
let tuple:[string, number];
tuple = ['1',1];
console.log(tuple);

// 枚举
enum Color {
  green = 10,
  red = 11,
  yellow = 12
}
// 根据属性获取值
let result1:Color = Color.red;
console.log(result1);
// 根据值获取属性名
let result2:string = Color[11];
console.log(result2);

// any
let data:any = 12;
data = true
console.log(data);
```

#### 限制变量类型

方式：

- 变量类型限定：变量名:类型名
- 函数类型限定：函数名(变量名:类型名):类型名{}

#### 联合类型

方式：变量:(类型1|类型2)

```typescript
let data2:string|number = '12';
data2=100
console.log(data2);

function test(arg:string|number){
  if(typeof arg === 'string'){
    return arg.length;
  }else{
    return arg.toString().length;
  }
}
console.log(test('100000'));
```



#### 类型断言

作用：可以用来手动指定一个值的类型

```typescript
function test2(x: string | number ){
  if((<string>x).length){
    return (x as string).length;
  }else{
    return x.toString().length;
  }
}
console.log(test2('100000'));
```



#### 类型推断

作用：可以用来手动指定一个值的类型

使用方式：**<>** 或 **as**

- **<**类型**>**值
- 值 **as** 类型，tsx中只能用这种方式

```typescript
function test2(x: string | number ){
  if((<string>x).length){
    return (x as string).length;
  }else{
    return x.toString().length;
  }
}
console.log(test2('100000'));
```



#### 类型推断

作用：当变量类型不明确时，ts自动为它推断一种类型，并且此后不可修改该变量类型

```typescript
let data3 = '100'; // ts将data3推断成了字符串
// data3 = 100; // data3重新赋值成其他类型，就会报错
console.log(data3);
```



### 4、接口

接口定义了对象内部的结构，确保内部结构的正确性。

#### 定义接口

```typescript
interface IPerson {
  id: string,
  name: string,
  sex: string,
  age: number
}

let person: IPerson = {
  id: '007',
  name: 'James',
  sex: 'man',
  age: 40
}

console.log(person.name);
```



#### 只读属性

属性名前添加`readonly`关键字

```typescript
interface IPerson {
  readonly id: string,
  name: string,
  sex: string,
  age: number
}
```



#### 可选属性

属性名后添加`?`，代表该属性是非必须的

```typescript
interface IPerson {
  id: string,
  name: string,
  sex: string,
  age?: number
}
```



#### 限定函数类型

```Typescript
interface searchFun {
  (str: string, flag: string):boolean
}
const fn1: searchFun = function(str: string, flag: string):boolean {
  return str.indexOf(flag) > -1;
}

console.log(fn1('hello','o'));
```



#### 限定 class 类型

接口去定义抽象行为，类通过**关键字** `implements` 实现接口的方法

```typescript
interface Hobby{
  wachMovie():void,
}
class person1 implements Hobby {
  wachMovie(){
    console.log('I like the Titanic');
  }
}
let p1 = new person1();
p1.wachMovie()
```



一个类可以实现多个接口

```typescript
interface Hobby{
  wachMovie():void,
}
interface Work{
  toWork():void,
}
class person1 implements Hobby, Work {
  wachMovie(){
    console.log('I like the Titanic');
  }
  toWork(){
    console.log('I will go to ZOL to work!');
  }
}
let p1 = new person1();
p1.wachMovie();
p1.toWork();
```



一个接口也可以**继承(extends)**多个接口

```typescript
interface Hobby{
  wachMovie():void,
}
interface Work{
  toWork():void,
}
interface Behavior extends Hobby, Work{
  toSay():void,
}
class person2 implements Behavior {
  toSay(){
    console.log('please say Hi!');
  }
  wachMovie(){
    console.log('I like the Iron Man');
  }
  toWork(){
    console.log('I will go to Beijing to work!');
  }
}
```



### 5、类

```typescript
class Shelby {

  firstName:string;
  lastName:string;
  fullName:string;

  constructor(firstName:string, lastName:string){
    this.firstName = firstName;
    this.lastName = lastName;
    this.fullName = firstName + '·' + lastName;
  }
}

interface person {
  firstName:string;
  lastName:string;
  fullName:string;
}

const getName = function(person:person){
  return `hello ${person.fullName}`;
}

let person1 = new Shelby('Tommy','Shelby');
console.log(getName(person1))
```

### 6、使用webpack打包Ts项目

依赖配置：

```
"devDependencies": {
    "clean-webpack-plugin": "^4.0.0",
    "cross-env": "^7.0.3",
    "html-webpack-plugin": "^3.2.0",
    "ts-loader": "^8.0.11",
    "typescript": "^4.6.2",
    "webpack": "^4.41.5",
    "webpack-cli": "^3.3.10",
    "webpack-dev-server": "^3.10.2"
  }
```

webpack.config.js

```javascript
const {CleanWebpackPlugin} = require('clean-webpack-plugin')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const path = require('path')

const isProd = process.env.NODE_ENV === 'production' // 是否生产环境

function resolve (dir) {
  return path.resolve(__dirname, '..', dir)
}

module.exports = {
  mode: isProd ? 'production' : 'development',
  entry: {
    app: './src/main.ts'
  },

  output: {
    path: resolve('dist'),
    filename: '[name].[contenthash:8].js'
  },

  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: 'ts-loader',
        include: [resolve('src')]
      }
    ]
  },

  plugins: [
    new CleanWebpackPlugin({
    }),

    new HtmlWebpackPlugin({
      template: './public/index.html'
    })
  ],

  resolve: {
    extensions: ['.ts', '.tsx', '.js']
  },

  devtool: isProd ? 'cheap-module-source-map' : 'cheap-module-eval-source-map',

  devServer: {
    host: 'localhost', // 主机名
    stats: 'errors-only', // 打包日志输出输出错误信息
    port: 8081,
    open: true
  },
}
```

















